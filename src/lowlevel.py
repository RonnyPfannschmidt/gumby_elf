import os
import sys
import stat
import hashlib
import base64
import subprocess
import wheel.paths

from setuptools_scm import get_version

PATHS = wheel.paths.get_install_paths('GumbyElf')
BOOTSTRAP_TEMPLATE = """
# development script generated by gumby elf
import os
__path__ = [{srcfolder!r}]
__file__ = os.path.join({srcfolder!r}, '__init__.py')
del os
execfile(__file__)
"""
SCRIPT_TEMPLATE = """\
#!{executable}
from {module} import {attr}
{attr}()
"""



def record_hash(data):
    return 'sha1=' + base64.urlsafe_b64encode(hashlib.sha1(data).digest())


def script_name(name):
    return os.path.join(PATHS['scripts'], name)


def get_script(entrypoint):
    module, attr = entrypoint.split(':')
    return SCRIPT_TEMPLATE.format(
        module=module,
        attr=attr,
        executable=sys.executable,
    )




def generate_scripts(spec):
    #XXX: windows scripts
    ep = spec.data.get('entrypoints', {})
    scripts = ep.get('console_scripts', {})
    for name, entrypoint in scripts.items():
        yield script_name(name), get_script(entrypoint)




class FileBundle(object):
    def __init__(self):
        self.needed_folders = set()
        self.files = {}
        self.finalized = False


    def add_file(self, name, data):
        assert not self.finalized
        dirname = os.path.dirname(name)
        if dirname:
            self.needed_folders.add(dirname)
        self.files[name] = data

    def finalize(self, record_filename):
        record_entries = [
            (name, record_hash(data))
            for name, data in sorted(self.files.items())
        ]
        record_entries.append((record_filename, ''))
        self.files[record_filename] = '\n'.join(
            ','.join(x) for x in record_entries)
        self.finalized = True

    def to_filesystem(self):
        for folder in sorted(self.needed_folders):
            # will autouse abs if folder is abspath
            folder = os.path.join(PATHS['purelib'], folder)
            if not os.path.isdir(folder):
                os.makedirs(folder)

        for name, data in sorted(self.files.items()):
            # will autouse abspath if name is abs
            path = os.path.join(PATHS['purelib'], name)
            with open(path, 'w') as fp:
                fp.write(data)
            #XXX: unix only
            if path.startswith(PATHS['scripts']):
                mode = os.stat(path).st_mode
                os.chmod(path, mode|stat.S_IXUSR)





def metadata_11(spec):
    #XXX: better pathhandling
    #XXX: incomplete
    version = get_version()
    result = [
        'Name: $(name)\n' % spec.data,
        'Version: ' + version + '\n',
    ]
    return ''.join(result)


def bootstraper(spec):
    fn = os.path.abspath(spec.filename)
    srcdir = os.path.join(os.path.dirname(fn), 'src')
    return BOOTSTRAP_TEMPLATE.format(srcfolder=srcdir)



def install_develop_data(spec):
    bundle = FileBundle()

    distinfo_folder = '%(name)s-develop.dist-info' % spec.data
    bundle.add_file(os.path.join(distinfo_folder, 'REQUESTED'), '')

    bundle.add_file(
        os.path.join(distinfo_folder, 'METADATA'),
        metadata_11(spec),
    )
    bundle.add_file(os.path.join(distinfo_folder, 'INSTALLER'), 'gumby elf')
    bundle.add_file(spec.data['package'] + '.py', bootstraper(spec))


    for name, script in generate_scripts(spec):
        bundle.add_file(name, script)

    bundle.finalize(os.path.join(distinfo_folder, 'RECORD'))
    bundle.to_filesystem()


def install_develop_dependencies(spec):

    package = spec.data

    requires = [
        k if v == 'latest' else '%s=%s' % (k, v)
        for k, v in package['dependencies'].items()
    ] + [
        k if v == 'latest' else '%s=%s' % (k, v)
        for k, v in package.get('dependenciesDev', {}).items()
    ]

    subprocess.check_call(['pip', 'install', '-q', '-U'] + requires)

